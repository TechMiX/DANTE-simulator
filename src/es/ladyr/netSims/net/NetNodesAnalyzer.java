/*
 * Copyright 2008 Luis Rodero Merino.  All Rights Reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Luis Rodero Merino if you need additional information or
 * have any questions. Contact information:
 * Email: lrodero AT gsyc.es
 * Webpage: http://gsyc.es/~lrodero
 * Phone: +34 91 488 8107; Fax: +34 91 +34 91 664 7494
 * Postal address: Desp. 121, Departamental II,
 *                 Universidad Rey Juan Carlos
 *                 C/Tulipán s/n, 28933, Móstoles, Spain 
 *       
 */

package es.ladyr.netSims.net;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.TreeSet;

import es.ladyr.util.commandLine.CommandLineParser;

public class NetNodesAnalyzer {
    
    private static NetNodesAnalyzer _instance = null;

    private final static String HELP_ARG_NAME = CommandLineParser.DEFAULT_ARGUMENT_NAMES_HEADER + "help";
    private final static String AVER_DEG_PER_NODE_CAP = CommandLineParser.DEFAULT_ARGUMENT_NAMES_HEADER + "degPerCap";
    private final static String OUTPUTFILE_ARG_NAME = CommandLineParser.DEFAULT_ARGUMENT_NAMES_HEADER + "outFile";
    private final static String DIGESTED_OUTPUTFILE_ARG_NAME = CommandLineParser.DEFAULT_ARGUMENT_NAMES_HEADER + "digestedOutFile";
    
    private static final String[] commandLineArgsNames = {HELP_ARG_NAME, AVER_DEG_PER_NODE_CAP, OUTPUTFILE_ARG_NAME, DIGESTED_OUTPUTFILE_ARG_NAME};
    
    private static final String USAGE = "java " + NetNodesAnalyzer.class.getName()
                                        + " {" + HELP_ARG_NAME + "}"
                                        + " {" + AVER_DEG_PER_NODE_CAP + "}"
                                        + " {" + OUTPUTFILE_ARG_NAME + " <fileName>}"
                                        + " {" + DIGESTED_OUTPUTFILE_ARG_NAME + " <fileName>}"
                                        + " { <nodesStateFile1> <nodesStateFile2> ... }\n"
                                        + " Please note that " + AVER_DEG_PER_NODE_CAP + " expects nodes state files as generated by the dante simulator.\n"
                                        + " Please note that " + DIGESTED_OUTPUTFILE_ARG_NAME + " prints output (one line per file) in the same order that files are given.";
    
    private static void printUsage(){
        System.out.println("Usage: " + USAGE + "\n");
    }   
    
    public static void main(String args[]){  
        
        CommandLineParser commandLineParser = new CommandLineParser();
        
        String unknownArg = commandLineParser.lookForUnknownArguments(args, commandLineArgsNames);
        if(unknownArg != null){
            System.out.println("Unknown argument " + unknownArg);
            printUsage();
            return;
        }
        
        boolean printHelp = commandLineParser.isArgPresent(args, HELP_ARG_NAME);
        if(printHelp){
            printUsage();
            return;
        }
        
        boolean computeAverDegPerCap = commandLineParser.isArgPresent(args, AVER_DEG_PER_NODE_CAP);

        if(!computeAverDegPerCap){
            System.out.println("Nothing to do.");
            printUsage();
            return;
        }
        
        String outputFileName = commandLineParser.getArgVal(args, OUTPUTFILE_ARG_NAME);
        
        if((outputFileName == null) && (commandLineParser.isArgPresent(args, OUTPUTFILE_ARG_NAME))){
            System.out.println("Could not find name for output file");
            printUsage();
            return;            
        }
        
        PrintWriter outputFileWriter = null;
        if(outputFileName != null) {
            try {
                outputFileWriter = new PrintWriter(new File(outputFileName));
            } catch (FileNotFoundException exception) {
                throw new Error("This FileNotFoundException should not happen", exception);
            }
            outputFileWriter.println("# NET");
            outputFileWriter.println("# Capacity\tAver. Degree");
            outputFileWriter.flush();
        }
        
        String digestedOutputFileName = commandLineParser.getArgVal(args, DIGESTED_OUTPUTFILE_ARG_NAME);
        
        if((digestedOutputFileName == null) && (commandLineParser.isArgPresent(args, DIGESTED_OUTPUTFILE_ARG_NAME))){
            System.out.println("Could not find name for output file with digested results");
            printUsage();
            return;            
        }
        
        PrintWriter digestedOutputFileWriter = null;
        if(digestedOutputFileName != null) {
            try {
                digestedOutputFileWriter = new PrintWriter(new File(digestedOutputFileName));
            } catch (FileNotFoundException exception) {
                throw new Error("This FileNotFoundException should not happen", exception);
            }
        }
        
        args = commandLineParser.removeArg(args, HELP_ARG_NAME);
        args = commandLineParser.removeArg(args, AVER_DEG_PER_NODE_CAP);
        args = commandLineParser.removeArgAndVal(args, OUTPUTFILE_ARG_NAME);
        args = commandLineParser.removeArgAndVal(args, DIGESTED_OUTPUTFILE_ARG_NAME);
        
        if(args.length == 0){
            System.out.println("No input files");
            printUsage();
            if(outputFileWriter != null)
                outputFileWriter.close();
            return;
        }
        
        for(int fileIndex = 0; fileIndex < args.length; fileIndex++){
            
            File dataFile = new File(args[fileIndex]);
            System.out.print("Reading nodes data file " + dataFile.getAbsolutePath() + "... ");
            NodeData[] nodesData = getInstance().readNodesStateFromFile(dataFile);
            System.out.println("done");

            if(outputFileWriter != null) outputFileWriter.println("# NodesStateFile-" + dataFile.getAbsolutePath());
            
            System.out.print("Processing data... ");
            HashMap degreesPerCap = new HashMap();
            for(int nodeIndex = 0; nodeIndex < nodesData.length; nodeIndex++){
                NodeData nodeData = nodesData[nodeIndex];
                Double capacity = new Double(nodeData.getCapacity());
                ArrayList degrees = (ArrayList)degreesPerCap.get(capacity);
                if(degrees == null) {
                    degrees = new ArrayList();
                    degreesPerCap.put(capacity, degrees);
                }
                Integer degree = new Integer(nodeData.getDegree());
                degrees.add(degree);
            }
            
            System.out.println( " done, " + degreesPerCap.size() + " different capacities, computing average degrees.");
            
            Double[] capacities = (Double[])(new TreeSet(degreesPerCap.keySet())).toArray(new Double[0]);

            // Header of digested output file (we could not do it before, as we did not know the different capacities that we could find
            if(fileIndex == 0)
                if(digestedOutputFileWriter != null) {
                    digestedOutputFileWriter.print("# Count");
                    for(int capsIndex = capacities.length - 1; capsIndex >= 0; capsIndex--) {
                        digestedOutputFileWriter.print("\tAvDegForCap:" + (Double)capacities[capsIndex]);                        
                    }
                    digestedOutputFileWriter.println();
                }
                    
            if(digestedOutputFileWriter != null) digestedOutputFileWriter.print((fileIndex+1));
            
            for(int capsIndex = capacities.length - 1; capsIndex >= 0; capsIndex--) {
                Double capacity = (Double)capacities[capsIndex];
                ArrayList degrees = (ArrayList)degreesPerCap.get(capacity);
                long degreesSum = 0;
                for(int degreeIndex = 0; degreeIndex < degrees.size(); degreeIndex++)
                    degreesSum += ((Integer)degrees.get(degreeIndex)).intValue();
                double averDegree = ((double)degreesSum)/degrees.size();
                
                if(digestedOutputFileWriter != null) digestedOutputFileWriter.print("\t" + averDegree);

                System.out.println("Capacity " + capacity + " ; average degree " + averDegree);
                
                if(outputFileWriter != null) outputFileWriter.println(capacity + "\t" + averDegree);
            }

            if(digestedOutputFileWriter != null) digestedOutputFileWriter.println();            
            
            System.out.println("done");
            
        }

        if(outputFileWriter != null)
            outputFileWriter.close();
        
        if(digestedOutputFileWriter != null)
            digestedOutputFileWriter.close();
        
    }    
    
    private NodeData[] readNodesStateFromFile(File nodesStateFile){
    
        if(nodesStateFile == null)
            throw new IllegalArgumentException("File can not be null");
        
        BufferedReader fileReader = null;
        try {
            fileReader = new BufferedReader(new FileReader(nodesStateFile));
        } catch (FileNotFoundException exception) {
            throw new Error("FileNotFoundException caught when opening file " + nodesStateFile.getAbsolutePath(), exception);
        }
        
        ArrayList nodesData = new ArrayList();
        
        String line = getLine(fileReader);
        while(line != null) {
            
            String[] lineParts = line.split("[\\s]+");
            if(lineParts.length != 6)
                throw new Error("Error parsing node state line " + line + ", can not split it in six parts (separated by white spaces).");
            
            double capacity = -1.0;
            
            try {
                capacity = Double.parseDouble(lineParts[1]);
            } catch(NumberFormatException exception){
                throw new Error("Could not parse " + lineParts[1] + " to a valid double");                
            }
            
            if(capacity <= 0)
                throw new Error("Capacity must be greater than 0, found " + capacity + " value");
            
            int degree = -1;
            
            try {
                degree = Integer.parseInt(lineParts[2]);
            } catch(NumberFormatException exception){
                throw new Error("Could not parse " + lineParts[2] + " to a valid integer");                
            }
            
            if(degree < 0)
                throw new Error("Degree must be positive, found " + degree + " value");
            
            nodesData.add(new NodeData(capacity, degree));            
            
            line = getLine(fileReader);
        }
        
        return (NodeData[])nodesData.toArray(new NodeData[0]);
    }

    private String getLine(BufferedReader fileReader){
    
        String line = null;
        do{
            try {
                line = fileReader.readLine();
            } catch (IOException exception) {
                throw new Error("IOException caught when reading line from BufferedReader", exception);
            }            
            if(line == null)
                return null;           
            line = line.trim();
        } while((line.startsWith("#")) || (line == "")); // Avoiding empty and commented lines in file
    
        return line;
    }
    
    public static NetNodesAnalyzer getInstance(){
        if(_instance == null)
            _instance = new NetNodesAnalyzer();
        return _instance;
    }

}

class NodeData {
    
    private double capacity = -1;
    private int degree = -1;
    
    public NodeData(double capacity, int degree){
        this.capacity = capacity;
        this.degree = degree;
    }
    
    public double getCapacity(){
        return capacity;
    }
    
    public int getDegree(){
        return degree;
    }
    
}
